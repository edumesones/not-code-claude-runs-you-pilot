#!/usr/bin/env node

/**
 * CLAUDE.md Consolidation System
 *
 * Generates compact context file (<150 lines) from memory state
 * Prioritizes by confidence and recency
 */

const fs = require('fs');
const path = require('path');

const MEMORY_DIR = process.env.MEMORY_DIR || '.memory';
const STATE_FILE = path.join(MEMORY_DIR, 'state.json');
const OUTPUT_FILE = process.env.OUTPUT_FILE || 'CLAUDE.md';
const MAX_LINES = parseInt(process.env.MAX_LINES || '150');

/**
 * Load state.json
 */
function loadState() {
  try {
    const content = fs.readFileSync(STATE_FILE, 'utf8');
    return JSON.parse(content);
  } catch (error) {
    console.error('‚ùå Error loading state.json:', error.message);
    process.exit(1);
  }
}

/**
 * Generate CLAUDE.md content
 */
function generateClaudeMd(state) {
  const memories = state.memories;

  // Group by category
  const byCategory = memories.reduce((acc, memory) => {
    if (!acc[memory.category]) acc[memory.category] = [];
    acc[memory.category].push(memory);
    return acc;
  }, {});

  // Sort each category by confidence (descending)
  Object.keys(byCategory).forEach(category => {
    byCategory[category].sort((a, b) => {
      // Primary: confidence
      if (b.confidence !== a.confidence) {
        return b.confidence - a.confidence;
      }
      // Secondary: recency
      return new Date(b.source.timestamp) - new Date(a.source.timestamp);
    });
  });

  let output = [];

  // Header
  output.push('# Project Context (Auto-Generated by Memory-MCP)');
  output.push('');
  output.push(`> ü§ñ Last updated: ${new Date().toISOString()}`);
  output.push(`> üìä Features: ${state.metadata.features_processed.length} | Memories: ${state.metadata.total_memories} | Avg confidence: ${state.metadata.confidence_avg.toFixed(2)}`);
  output.push('');

  // Category priorities (most important first)
  const categoriesToInclude = [
    { name: 'Architecture', icon: 'üèóÔ∏è', limit: 15 },
    { name: 'Decisions', icon: '‚öñÔ∏è', limit: 20 },
    { name: 'Patterns', icon: 'üß©', limit: 15 },
    { name: 'Gotchas', icon: '‚ö†Ô∏è', limit: 15 },
    { name: 'Progress', icon: 'üìà', limit: 10 }
  ];

  categoriesToInclude.forEach(({ name, icon, limit }) => {
    if (byCategory[name] && byCategory[name].length > 0) {
      output.push(`## ${icon} ${name}`);
      output.push('');

      // Take top N memories
      const topMemories = byCategory[name].slice(0, limit);

      topMemories.forEach(memory => {
        // Confidence indicator
        const confidenceEmoji = memory.confidence >= 0.9 ? '‚úÖ'
                              : memory.confidence >= 0.7 ? 'üü°'
                              : '‚ö†Ô∏è';

        // Remove feature ID prefix for readability
        let content = memory.content.replace(/^FEAT-\d+-[^:]+:\s*/, '');

        // Truncate long content
        if (content.length > 120) {
          content = content.substring(0, 117) + '...';
        }

        output.push(`- ${confidenceEmoji} ${content}`);

        // Add source reference if available
        if (memory.references && memory.references.length > 0) {
          const ref = memory.references[0];
          output.push(`  _Source: ${ref}_`);
        }
      });

      output.push('');
    }
  });

  // Feature progress summary
  output.push('## üéØ Current Progress');
  output.push('');

  if (state.metadata.features_processed.length > 0) {
    // Group memories by feature to determine status
    const featureStatus = {};
    state.metadata.features_processed.forEach(featureId => {
      const featureMemories = memories.filter(m => m.source.feature === featureId);
      const hasWrapUp = featureMemories.some(m => m.source.phase === 'WrapUp');
      const phases = [...new Set(featureMemories.map(m => m.source.phase))];

      featureStatus[featureId] = {
        complete: hasWrapUp,
        phases: phases.length,
        lastUpdate: new Date(Math.max(...featureMemories.map(m => new Date(m.source.timestamp))))
      };
    });

    // Sort by last update (most recent first), limit to last 10
    const recentFeatures = Object.entries(featureStatus)
      .sort((a, b) => b[1].lastUpdate - a[1].lastUpdate)
      .slice(0, 10);

    recentFeatures.forEach(([featureId, status]) => {
      const statusEmoji = status.complete ? '‚úÖ' : 'üü°';
      const phaseInfo = status.complete ? 'Complete' : `${status.phases} phases`;
      output.push(`- ${statusEmoji} **${featureId}** (${phaseInfo})`);
    });
  } else {
    output.push('- No features processed yet');
  }

  output.push('');

  // Footer
  output.push('---');
  output.push('');
  output.push('üí° **Tip:** For detailed memories, use MCP tools:');
  output.push('- `mcp-cli call memory/search \'{"query":"category:Decisions"}\'`');
  output.push('- `mcp-cli call memory/search \'{"query":"phase:Analysis"}\'`');
  output.push('');
  output.push(`_Memory system v${state.metadata.schema_version} | Decay: ${state.config.confidence_decay_enabled ? 'ON' : 'OFF'}_`);

  const content = output.join('\n');

  // Check line count
  const lines = content.split('\n');
  if (lines.length > MAX_LINES) {
    console.warn(`‚ö†Ô∏è  Output exceeds ${MAX_LINES} lines (${lines.length}), truncating...`);

    // Keep header + categories + truncation notice
    const truncated = lines.slice(0, MAX_LINES - 3);
    truncated.push('');
    truncated.push('_...truncated for brevity (see .memory/state.json for full details)_');
    return truncated.join('\n');
  }

  return content;
}

/**
 * Validate CLAUDE.md content
 */
function validateContent(content) {
  const issues = [];

  // Check for secrets (paranoid check)
  const secretPatterns = [
    /api[_-]?key\s*[:=]/gi,
    /password\s*[:=]/gi,
    /bearer\s+[a-zA-Z0-9]/gi,
  ];

  secretPatterns.forEach(pattern => {
    if (pattern.test(content)) {
      issues.push(`Potential secret detected: ${pattern.toString()}`);
    }
  });

  // Check line count
  const lines = content.split('\n').length;
  if (lines > MAX_LINES) {
    issues.push(`Exceeds max lines: ${lines} > ${MAX_LINES}`);
  }

  return issues;
}

/**
 * Main execution
 */
try {
  console.log('\nüîÑ Generating CLAUDE.md...');

  const state = loadState();
  const content = generateClaudeMd(state);

  // Validate
  const issues = validateContent(content);
  if (issues.length > 0) {
    console.warn('‚ö†Ô∏è  Validation warnings:');
    issues.forEach(issue => console.warn(`   - ${issue}`));
  }

  // Backup existing CLAUDE.md
  if (fs.existsSync(OUTPUT_FILE)) {
    const backupPath = OUTPUT_FILE + '.backup';
    fs.copyFileSync(OUTPUT_FILE, backupPath);
  }

  // Write output
  fs.writeFileSync(OUTPUT_FILE, content, 'utf8');

  const lineCount = content.split('\n').length;
  console.log(`‚úÖ Generated ${OUTPUT_FILE} (${lineCount} lines)`);
  console.log(`üìä Included ${state.metadata.total_memories} memories from ${state.metadata.features_processed.length} features`);

  if (lineCount > MAX_LINES * 0.9) {
    console.warn(`‚ö†Ô∏è  Approaching line limit (${lineCount}/${MAX_LINES})`);
    console.warn('   Consider pruning low-confidence memories');
  }

} catch (error) {
  console.error(`‚ùå Error: ${error.message}`);
  process.exit(1);
}
